import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
import de.dosmike.sponge.pluginpublisher.gradle.NotifyDiscordBotTask
import de.dosmike.sponge.pluginpublisher.gradle.PublishToGitTask
import de.dosmike.sponge.pluginpublisher.gradle.PublishToOreTask
import de.dosmike.sponge.pluginpublisher.tasks.DiscordBotConfiguration
import de.dosmike.sponge.pluginpublisher.tasks.GitConfiguration
import de.dosmike.sponge.pluginpublisher.tasks.OreConfiguration
import de.dosmike.sponge.pluginpublisher.tasks.TaskFunctors

plugins {
    id 'java'
    id 'maven'
    id 'idea'
    id 'org.spongepowered.plugin' version '0.9.0'
    id 'com.github.johnrengelman.shadow' version '5.1.0'
    id 'com.github.dosmike.PluginPublisher' version '1.2.2'
}
group = 'com.github.dosmike'

//auto fetch version from McMod.info
def jsonFile = file('src/main/resources/mcmod.info')
def parsedJson = new groovy.json.JsonSlurper().parseText(jsonFile.text)
def pluginid = parsedJson[0].modid
if (version == 'unspecified') {
    // jitpack will inject and expect it's own version (e.g. master-SNAPSHOT)
    version = parsedJson[0].version
}
assert (pluginid instanceof String) && !((String)pluginid).isEmpty()
println rootProject.name + ' (' + pluginid + ') version ' + version

def serverDir = 'G:/Sonstige/VanillaSponge/server'

sourceCompatibility = 1.8 // java 8
targetCompatibility = 1.8

repositories {
    mavenCentral()
    jcenter()
    maven { url "https://jitpack.io" }
    maven { url "https://files.minecraftforge.net/maven" }
    maven { url "https://repo.spongepowered.org/maven" }
}
configurations {
    //don't get dependencies of these dependencies, would bloat uber jar
    shadow.transitive false
}

dependencies {
    compileOnly 'org.jetbrains:annotations:16.0.2'
    // required deps
    compileOnly 'org.spongepowered:spongeapi:7.3.0-SNAPSHOT'
    compileOnly 'com.github.DosMike:MegaMenus:develop-SNAPSHOT'
    compileOnly 'com.github.DosMike:LangSwitch:development-SNAPSHOT'
    // optional deps
    compileOnly 'com.github.DosMike:TooMuchStock:master-SNAPSHOT'
    compileOnly 'com.github.bloodmc:GriefDefenderAPI:master-SNAPSHOT'
    compileOnly 'com.github.JimiIT92:UniverseGuardAPI7:master-SNAPSHOT'
    compileOnly fileTree(dir: 'libs', include: ['RedProtect-*-Universal.jar'])
    compileOnly fileTree(dir: 'libs', include: ['HuskyCrates-*.jar'])

    shadow 'com.github.DosMike:SpongePluginVersionChecker:master-SNAPSHOT'
}

task removeOldVersions(type: Delete) {

    def files = fileTree('./build/libs', {
        include "**/${jar.archiveBaseName.get()}-*.jar"
        exclude { jar.outputs }
    }) + fileTree('./distributions', {
        exclude { zReleaseZip.outputs }
    }) + fileTree("${serverDir}/mods", {
        include "**/${jar.archiveBaseName.get()}-*.jar"
        exclude "**/"+jar.archiveFileName.get()
    })
    outputs.upToDateWhen {
        files.empty
    }
    delete files

}

task uberJar(type: ShadowJar, group:'_Plugin', dependsOn:removeOldVersions) {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    exclude 'META-INF/**'
    manifest {
        attributes('Implementation-Title': project.name,
                'Implementation-Version': project.version)
    }
    configurations = [project.configurations.shadow]
    //relocate the version checker to avoid problems with different versions of versionChecker in different plugins
    //conveniently the plugin id supports a limited character set that can be used as package name
    relocate('de.dosmike.sponge', 'shadow.dosmike.versionchecker.'+pluginid) {
        //don't relocate my actual plugins - yes, includes are paths!
        include "de/dosmike/sponge/VersionChecker"
        include "de/dosmike/sponge/VersionChecker\$Version"
    }
    from(sourceSets.main.resources)
    from(sourceSets.main.output)
    archiveClassifier.set( null )
}
task pushToServer(type: Copy, group:'_Plugin', dependsOn:uberJar) {
    if (new File(serverDir).exists()) {
        from uberJar.outputs.files
        into file("${serverDir}/mods")
    }
}
task _runServer(type: Exec,group:'_Plugin', dependsOn:pushToServer) {
    if (new File(serverDir).exists()) {
        workingDir file(serverDir)
        //double cmd to detach from ide terminal
        commandLine 'cmd', '/c', 'start', 'cmd', '/c', 'startServer.bat'
    }
}
task rebuild(group:'_Plugin') {
    dependsOn clean
    mustRunAfter clean
    finalizedBy uberJar
}

task zReleaseZip(type: Zip, group:'_Plugin', dependsOn: uberJar) {
    onlyIf { file('release').exists() }
    archiveBaseName.set( jar.archiveBaseName.getOrNull() )
    archiveAppendix.set( jar.archiveAppendix.getOrNull() )
    archiveVersion.set( jar.archiveVersion.getOrNull() )
    archiveClassifier.set( jar.archiveClassifier.getOrNull() )
    archiveExtension.set( 'zip' )

    from ('release') {
        exclude '**/*.zip'
        exclude '**/.gitignore'
    }
    from (jar.outputs.files) {
        into 'mods'
    }
}
task z_Publish(group:'_Plugin', dependsOn:zReleaseZip) {
    def keyfile = file('..\\PluginPublisher\\.apikeys')
    onlyIf { keyfile.exists() }
    outputs.upToDateWhen {false}
    def props, versionDesc
    doFirst {
        props = new Properties()
        file('..\\PluginPublisher\\.apikeys').withInputStream {
            props.load(it)
        }
        //show an input prompt
        versionDesc = TaskFunctors.validateReleaseDescription(null, false)
    }
    doLast {
        project.zPub_Git.apiKey.set    ( props.getProperty('gitkey') )
        project.zPub_Ore.apiKey.set    ( props.getProperty('orekey') )
        project.zPub_Discord.apiKey.set( props.getProperty('discordkey') )

        project.zPub_Git.messageBody.set    ( versionDesc )
        project.zPub_Ore.messageBody.set    ( versionDesc )
        project.zPub_Discord.messageBody.set( versionDesc )
    }
}
task zPub_Git(type: PublishToGitTask, group:'_Plugin', dependsOn: z_Publish) {
    gitSlug.set     ( 'DosMike/VillagerShops' )
    versionTag.set  ( project.version.toString() )
    versionName.set ( "Release Build ${project.version}" )
    uploadAssets.set( zReleaseZip.outputs.files )
}
task zPub_Ore(type: PublishToOreTask, group:'_Plugin', dependsOn: z_Publish) {
    projectId.set  ( pluginid.toString() )
    channel.set    ( 'Release' )
    uploadAsset.set( jar.outputs.files )
}
task zPub_Discord(type: NotifyDiscordBotTask, group:'_Plugin', dependsOn: z_Publish) {
    guildId.set      ( '342942444288999435' )
    channelId.set    ( '773123356722462752' )
    messageHeader.set( "<@&794978576256335883> Version ${version} released on Ore and GitHub" )
    finalizedBy(TerminateDiscordBot)
}
z_Publish.finalizedBy(zPub_Git)
zPub_Git.finalizedBy(zPub_Ore)
zPub_Ore.finalizedBy(zPub_Discord)

//for generating the jar
jar {
    manifest {
        attributes('Implementation-Title': project.name,
                'Implementation-Version': project.version)
    }
}

//Rest is here in order to use this project as dependency (taken from jitpack example)
task sourcesJar(type: Jar, dependsOn: classes) {
    archiveClassifier.set( 'sources' )
    from sourceSets.main.allSource
}

task javadocJar(type: Jar, dependsOn: javadoc) {
    archiveClassifier.set( 'javadoc' )
    from javadoc.destinationDir
}

artifacts {
    archives uberJar
    archives sourcesJar
    archives javadocJar
}

// To specify a license in the pom:
install {
    repositories.mavenInstaller {
        pom.project {
            licenses {
                license {
                    name 'MIT License'
                    url 'https://github.com/DosMike/VillagerShops/blob/master/LICENSE'
                    distribution 'repo'
                }
            }
        }
    }
}

wrapper {
    gradleVersion = "6.7.1"
    distributionType = Wrapper.DistributionType.ALL
}